// ============================================================================
// src/app/state.rs
// ============================================================================
//
// このファイルでは、アプリケーション全体の状態を保持する AppState 構造体と、
// データ量の単位（文字数 / バイト数）を表す Unit 列挙型を定義する。
//
// AppState は、clip_frag の動作に必要なすべての情報を保持する「中心的な状態」。
// main_loop / finalize_loop / exit_loop のすべてが、この状態を参照しながら動く。
//
// 責務を明確にするため、ロジックはここには書かず、純粋なデータ構造だけを定義する。
// ============================================================================

// -----------------------------------------------------------------------------
// データ量の単位を表す列挙型
// -----------------------------------------------------------------------------
//
// - Chars: 文字数ベースで分割する
// - Bytes: バイト数ベースで分割する
//
// CLI の -c / -b オプションに対応する。
// -----------------------------------------------------------------------------
#[derive(Debug, Clone, Copy)]
pub enum Unit {
    Chars,
    Bytes,
}

// -----------------------------------------------------------------------------
// AppState 構造体
// -----------------------------------------------------------------------------
//
// アプリケーション全体の状態を保持する。
// これらの値は main_loop / finalize_loop / exit_loop の中で更新される。
// -----------------------------------------------------------------------------
pub struct AppState {
    /// 入力データ全体（UTF-8 の String として保持）
    pub input_text: String,

    /// 行単位に分割した入力データ
    pub lines: Vec<String>,

    /// 各行の「単位ごとの長さ」（chars または bytes）
    pub line_units: Vec<usize>,

    /// 入力データ全体の単位数（chars または bytes）
    pub total_units: usize,

    /// 一回に取り込む最大データ量
    pub max_unit: usize,

    /// データ量の単位（文字数 or バイト数）
    pub unit: Unit,

    /// 直前に取り込んだデータ
    pub prev_contents: String,

    /// 次に取り込むべき行 index（行単位）
    pub curr_index: usize,

    /// 入力データがファイル由来かどうか
    pub from_file: bool,

    /// 入力ファイル名（ファイル指定時のみ Some）
    pub input_file_name: Option<String>,
}

impl AppState {
    // -------------------------------------------------------------------------
    // AppState::new
    // -------------------------------------------------------------------------
    //
    // 入力テキストと CLI 設定から AppState を初期化する。
    // 行分割と単位計算もここで行う。
    //
    pub fn new(
        input_text: String,
        unit: Unit,
        max_unit: usize,
        from_file: bool,
        input_file_name: Option<String>,
    ) -> Self {
        // ------------------------------------------------------------
        // 行単位に分割する
        // ------------------------------------------------------------
        let lines = split_to_lines_preserve_newline(&input_text);

        // ------------------------------------------------------------
        // 各行の単位数（chars または bytes）を計算する
        // ------------------------------------------------------------
        let line_units: Vec<usize> = lines
            .iter()
            .map(|line| match unit {
                Unit::Chars => line.chars().count(),
                Unit::Bytes => line.len(),
            })
            .collect();

        // ------------------------------------------------------------
        // 入力データ全体の単位数を計算する
        // ------------------------------------------------------------
        let total_units: usize = line_units.iter().sum();

        // ------------------------------------------------------------
        // prev_contents は初期状態では空
        // （ファイル指定時は App::new 側でヘッダを設定する）
        // ------------------------------------------------------------
        let prev_contents = String::new();

        // curr_index は 0 から開始
        let curr_index = 0;

        Self {
            input_text,
            lines,
            line_units,
            total_units,
            max_unit,
            unit,
            prev_contents,
            curr_index,
            from_file,
            input_file_name,
        }
    }
}

// -----------------------------------------------------------------------------
// 行単位に分割するユーティリティ関数
// -----------------------------------------------------------------------------
//
// 行末の改行（\n または \r\n）を保持したまま分割する。
// これにより、元のテキスト構造を忠実に再現できる。
// -----------------------------------------------------------------------------
fn split_to_lines_preserve_newline(text: &str) -> Vec<String> {
    let mut lines = Vec::new();
    let mut start = 0;
    let bytes = text.as_bytes();
    let len = bytes.len();

    for i in 0..len {
        if bytes[i] == b'\n' {
            // \n を含めて 1 行とする
            let line = &text[start..=i];
            lines.push(line.to_string());
            start = i + 1;
        }
    }

    if start < len {
        // 最後の行（改行なし）を追加
        lines.push(text[start..].to_string());
    }

    lines
}
